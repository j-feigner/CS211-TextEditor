For this milestone, I was determined to visualize my sorting methods with an animation, because what O(N^2) algorithms lack in speed they make up for in looks. To do this, I needed to repurpose Adam's templated sorting functions to interface with curses, and output the partially sorted array at each iteration or swap as the algorithm chugs along. 

My editor first takes an input from the user on which algorithm they would like to perform, either Insertion, Selection, Bubble or Quick. After the user makes their selection, my program takes the raw two-dimensional text vector (of characters) and converts it to a standard vector of words (strings), deliminated by non-letter characters.

This vector is then passed to the respective sorting function. As swaps occur, a helper function to output the current state of the words array is called. The cumulative effect of these output functions create the "animation". I am proud of this design, because the sorting display isn't a trick or done after the fact; it is directly displaying the data being worked on as it is sorted. After the words are sorted, they are written out to a text file. Formatting is not maintained.

The thing that surprised me the most about this milestone was how easy all of this was to implement. Almost all of the code I needed could be repurposed from my previous work. The selection screen code was lifted from the auto-fill milestone; the conversion from text data to a vector of words used a modified function from the compression milestone. It would have taken a considerably longer time to write the sorting algorithms myself, so I am grateful that those were provided. The fact that these problems were mostly solved already either by myself or with Adam's code made the process of implementing the animation my sole focus, and that was the fun part!  I am happy this was our last milestone, because it was the most fun to develop out of all of them. I was even able to keep my main.cpp file relatively clean as I coded, having learned from my mistakes in past milestones.

This has taught me that larger projects might not be as scary as I first thought. They are overwhelming in the beginning, but as the ball gets rolling implementing new features become less daunting. Either because of code reuse or just a better understanding of your program in general. It was both in my case. I honestly didn't have any major hiccups during this milestone, and it was a ton of fun. I wish every coding assignment was this pretty to look at when you're finished.
